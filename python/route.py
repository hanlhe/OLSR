import unittest
from clock import Clock

class Route:

    def __init__(self, _nid):

        # @PreviousDesign
        # # One hop neighbor, Dict() with:
        # #   - key: neighbor id
        # #   - val: Tuple(List[unidir neighbors],List[bidir neighbors])
        # self.one_hop_neigh = dict()

        # Current node id.
        self.nid = _nid

        # Note that, there is no need to store the unidir neighbors list of a
        # one-hop neighbor. Only the bidirectional neighbors list is useful.
        # When generating HELLO message, we need the list of all unidir/bidir
        # neighbor, instead of a dict with key of neighbor id, use two set of
        # neighbor ids for each link state.
        self.unidir = set()
        self.bidir  = set()

        # # Two hop neighbor, Set() with all two hop neighbors.
        # # Generated by combining all values in the neighbor_map.
        # self.two_hop = set()

        # A helper dict to store the mapping of two-hop neighbor and
        # corresponding one-hop neighbor with:
        #   - key: one-hop neighbor id
        #   - val: Set(two-hop neighbor ids)
        # Only bidir links neighbor is included.
        self.neighbor_map = dict()
        self.neighbor_timestamp = dict()

        # MPR (Multipoint relays), Set() with all MPRs' id, which is a subset
        # of self.one_hop_neigh.
        self.mpr = set()

        # MS (MPR Selector Set), Set() with all MS id.
        self.ms = set()

        # Topology Table, Dict() with
        #   - key: Tuple(Destination_Addr, Last-Hop)
        #   - val: Tuple(MPR_SeqNo, Received_Timestamp)
        self.topo = dict()

        # Routing Table, Dict() with
        #   - key: Destination_Addr
        #   - val: Tuple(Next-Hop, Distance)
        self.route = dict()

    @property
    # Two hop neighbor, Set() with all two hop neighbors. Generated by
    # combining all values in the neighbor_map.
    def two_hop(self):
        if self.neighbor_map == {}:
            return set()
        return set.union(*list(self.neighbor_map.values()))

    def update_neighbor(self, neighbor, unidir, bidir):
        """ Update neighbor information of specific neighbor.
        Args:
            - neighbor (str): The id of the neighbor, which is the originator
              of the HELLO message.
            - unidir (Set[str]): The ids of node which is unidirectional
              neighbor of the HELLO message originator.
            - bidir (Set[str]): The ids of node which is bidirectional
              neighbor of the HELLO message originator.
        Returns:
            Self.
        """
        cur_time = Clock().time

        # If the neighbor is currently a bidirectional neighbor,
        #   1. Refresh the timestamp of its neighbor_map,
        #   2. Regenerated two-hop neighbor set based on new neighbor_map.
        if neighbor in self.bidir:
            self.neighbor_timestamp[neighbor] = cur_time
            bidir.discard(self.nid)
            self.neighbor_map[neighbor] = bidir
            return self

        # If current node is listed in the unidir or bidir, move (or add) the
        # neighbor to bidirectional neighbor set and add bidir to neighbor_map
        # and timestamp.
        if self.nid in bidir | unidir:
            self.unidir.discard(neighbor)
            self.bidir.add(neighbor)
            bidir.discard(self.nid)
            self.neighbor_map[neighbor] = bidir
            self.neighbor_timestamp[neighbor] = cur_time
            return self

        # Otherwise, neither the neighbor is currently neither a bidirectional
        # neighbor nor current node was listed in the bidir or unidir (i.e. the
        # neighbor was not aware of current node), add neighbor to
        # unidirectional neighbor (or remain the same) and refresh timestamp.
        self.unidir.add(neighbor)
        self.neighbor_timestamp[neighbor] = cur_time
        return self

    def select_mpr(self):
        pass

    def get_neighbor(self):
        pass

    def generate_hello(self):
        pass

    def generate_tc(self):
        pass

    def get_route(self, dst):
        pass



class TestRoute(unittest.TestCase):

    def test_update_neighbor(self):
        route = Route('a')
        route.update_neighbor('b', {'c', 'd'}, {'e','f'})
        self.assertEqual(route.unidir, {'b'})
        self.assertEqual(route.bidir, set())
        self.assertEqual(route.neighbor_timestamp, dict([('b', 0)]))
        self.assertEqual(route.two_hop, set())

        route.update_neighbor('c', {'d', 'a'}, {'g'})
        self.assertEqual(route.unidir, {'b'})
        self.assertEqual(route.bidir, {'c'})
        self.assertEqual(route.neighbor_timestamp, dict([('b', 0), ('c', 0)]))
        self.assertEqual(route.two_hop, {'g'})

        route.update_neighbor('b', {'c','d'}, {'e','f','a'})
        self.assertEqual(route.unidir, set())
        self.assertEqual(route.bidir, {'c', 'b'})
        self.assertEqual(route.neighbor_timestamp, dict([('b', 0), ('c', 0)]))
        self.assertEqual(route.two_hop, {'e','f', 'g'})



if __name__ == '__main__':
    unittest.main()
