import unittest
from clock import Clock
from copy import deepcopy

class Route:

    def __init__(self, _nid):

        # @PreviousDesign
        # # One hop neighbor, Dict() with:
        # #   - key: neighbor id
        # #   - val: Tuple(List[unidir neighbors],List[bidir neighbors])
        # self.one_hop_neigh = dict()

        # Current node id.
        self.__nid = _nid

        # Note that, there is no need to store the unidir neighbors list of a
        # one-hop neighbor. Only the bidirectional neighbors list is useful.
        # When generating HELLO message, we need the list of all unidir/bidir
        # neighbor, instead of a dict with key of neighbor id, use two set of
        # neighbor ids for each link state.
        self.__unidir = set()
        self.__bidir  = set()

        # # Two hop neighbor, Set() with all two hop neighbors.
        # # Generated by combining all values in the neighbor_map.
        # self.two_hop = set()

        # A helper dict to store the mapping of two-hop neighbor and
        # corresponding one-hop neighbor with:
        #   - key: one-hop neighbor id
        #   - val: Set(two-hop neighbor ids)
        # Only bidir links neighbor is included.
        self.__neighbor_map = dict()
        self.__neighbor_timestamp = dict()

        # MPR (Multipoint relays), Set() with all MPRs' id, which is a subset
        # of self.one_hop_neigh, and MPR set corresponding sequence number.
        self.__mpr = set()
        self.__mpr_seqno = 0

        # MS (MPR Selector Set), Set() with all MS id, and MS set corresponding
        # sequence number.
        self.__ms = set()
        self.__ms_seqno = 0

        # Topology Table, Dict() with
        #   - key: Tuple(Destination_Addr, Last-Hop)
        #   - val: Tuple(MPR_SeqNo, Received_Timestamp)
        self.__topo = dict()

        # Routing Table, Dict() with
        #   - key: Destination_Addr
        #   - val: Tuple(Next-Hop, Distance)
        self.__route = dict()

    # Getter method
    @property
    def nid(self):
        return self.__nid

    @property
    def bidir(self):
        return self.__bidir

    @property
    def unidir(self):
        return self.__unidir

    @property
    def neighbor_map(self):
        return deepcopy(self.__neighbor_map)

    @property
    def neighbor_timestamp(self):
        return self.__neighbor_timestamp

    @property
    def mpr(self):
        return self.__mpr, self.__mpr_seqno

    @property
    def ms(self):
        return self.__ms, self.__ms_seqno

    @property
    # Two hop neighbor, Set() with all two hop neighbors. Generated by
    # combining all values in the neighbor_map.
    def two_hop(self):
        if self.__neighbor_map == {}:
            return set()
        return set.union(*list(self.__neighbor_map.values()))

    def hello_update(self, neighbor, unidir, bidir, mpr):
        """ Update triggered by HELLO message.
            1. Invoke _update_neighbor to update neighbor table.
            2. Invoke select_mpr to reselect mpr set.
            3. Invode _update_ms to update MS set.
        """
        self._update_neighbor(neighbor, unidir, bidir)
        self._select_mpr()
        self._update_ms(neighbor, mpr)
        pass

    def _update_neighbor(self, neighbor, unidir, bidir):
        """ Update neighbor information of specific neighbor.
        Args:
            - neighbor (str): The id of the neighbor, which is the originator
              of the HELLO message.
            - unidir (Set[str]): The ids of node which is unidirectional
              neighbor of the HELLO message originator.
            - bidir (Set[str]): The ids of node which is bidirectional
              neighbor of the HELLO message originator.
        Returns:
            Self.
        """
        cur_time = Clock().time

        # If the neighbor is currently a bidirectional neighbor,
        #   1. Refresh the timestamp of its neighbor_map,
        #   2. Regenerated two-hop neighbor set based on new neighbor_map.
        if neighbor in self.__bidir:
            self.__neighbor_timestamp[neighbor] = cur_time
            bidir.discard(self.nid)
            self.__neighbor_map[neighbor] = bidir
            return self

        # If current node is listed in the unidir or bidir, move (or add) the
        # neighbor to bidirectional neighbor set and add bidir to neighbor_map
        # and timestamp.
        if self.__nid in bidir | unidir:
            self.__unidir.discard(neighbor)
            self.__bidir.add(neighbor)
            bidir.discard(self.nid)
            self.__neighbor_map[neighbor] = bidir
            self.__neighbor_timestamp[neighbor] = cur_time
            return self

        # Otherwise, neither the neighbor is currently neither a bidirectional
        # neighbor nor current node was listed in the bidir or unidir (i.e. the
        # neighbor was not aware of current node), add neighbor to
        # unidirectional neighbor (or remain the same) and refresh timestamp.
        self.__unidir.add(neighbor)
        self.__neighbor_timestamp[neighbor] = cur_time
        return self

    def _select_mpr(self):
        """ Select MPR set based on current bidir/two-hop neighbor set, using
        basic OLSR greedy strategy:

        >   Select first the neighbor that can reach the largest number of two
        >   hop neighbors, then the next neighbor that can select the most
        >   remaining two-hop neighbors, etc.

        Args:
            Self.
        Returns:
            Self.
        """

        # A helper function, recursively calculate MPR set.
        def __select_mpr__(neighbor_map, two_hop_set):
            if two_hop_set == set():
                return set()
            interset_count = lambda x: len(x & two_hop_set)
            convert = lambda x: (interset_count(x[1]), x[0])
            interset = set(map(convert, neighbor_map.items()))
            _,mpr = max(interset)
            two_hop_set = two_hop_set - neighbor_map[mpr]
            neighbor_map.pop(mpr)
            return {mpr} | __select_mpr__(neighbor_map, two_hop_set)

        two_hop_set = self.two_hop
        neighbor_map = self.neighbor_map
        new_mpr = __select_mpr__(neighbor_map, two_hop_set)
        if new_mpr == self.__mpr:
            return
        self.__mpr = new_mpr
        self.__mpr_seqno += 1

    def _update_ms(self, neighbor, mpr):
        """ Update MS set, add neighbor id to MS set if current node is the
            neighbor's MPR, or delete the neighbor in MS set if current node
            was no longer in the neighbor's MPR.
        Args:
            - neighbor (str): The id of the neighbor, which is the originator
              of the HELLO message.
            - mpr (Set(str)): The ids of MPR of the neighbor.
        Returns:
            Self
        """
        if self.nid in mpr:
            if neighbor in self.__ms:
                return
            self.__ms.add(neighbor)
            self.__ms_seqno += 1
        if neighbor in self.__ms and self.nid not in mpr:
            self.__ms.discard(neighbor)
            self.__ms_seqno += 1

    def generate_hello(self):
        pass

    def generate_tc(self):
        pass

    def get_route(self, dst):
        pass

class TestRoute(unittest.TestCase):

    def test_update_neighbor(self):
        route = Route('a')
        route._update_neighbor('b', {'c', 'd'}, {'e','f'})
        self.assertEqual(route.unidir, {'b'})
        self.assertEqual(route.bidir, set())
        self.assertEqual(route.neighbor_timestamp, dict([('b', 0)]))
        self.assertEqual(route.two_hop, set())

        route._update_neighbor('c', {'d', 'a'}, {'g'})
        self.assertEqual(route.unidir, {'b'})
        self.assertEqual(route.bidir, {'c'})
        self.assertEqual(route.neighbor_timestamp, dict([('b', 0), ('c', 0)]))
        self.assertEqual(route.two_hop, {'g'})

        route._update_neighbor('b', {'c','d'}, {'e','f','a'})
        self.assertEqual(route.unidir, set())
        self.assertEqual(route.bidir, {'c', 'b'})
        self.assertEqual(route.neighbor_timestamp, dict([('b', 0), ('c', 0)]))
        self.assertEqual(route.two_hop, {'e','f', 'g'})
        self.assertEqual(route.neighbor_map,
                dict([('c', {'g'}), ('b', {'e', 'f'})]))

    def test_select_mpr(self):
        route = Route('a')
        route._update_neighbor('b', {'c','d'}, {'e','f'})
        route._select_mpr()
        self.assertEqual(route.mpr, (set(),0))

        route._update_neighbor('c', {'d','a'}, {'g'})
        route._select_mpr()
        self.assertEqual(route.mpr, ({'c'},1))

        route._update_neighbor('b', {'c','d'}, {'e','f','a','p'})
        route._select_mpr()
        self.assertEqual(route.mpr, ({'c','b'},2))

        route._update_neighbor('d', {'d','a'}, {'x'})
        route._select_mpr()
        self.assertEqual(route.mpr, ({'c','b','d'},3))

        route._update_neighbor('d', {'d','a'}, {'x','g'})
        route._select_mpr()
        self.assertEqual(route.mpr, ({'b','d'},4))

        route._update_neighbor('e', {'d','a'}, {'f'})
        route._select_mpr()
        self.assertEqual(route.mpr, ({'b','d'},4))

    def test_hello_update(self):
        route = Route('a')

        route.hello_update('b', {'c','d'}, {'e','f'}, {})
        self.assertEqual(route.mpr, (set(),0))
        self.assertEqual(route.ms, (set(),0))

        route.hello_update('c', {'d','a'}, {'g'}, {'g'})
        self.assertEqual(route.mpr, ({'c'},1))
        self.assertEqual(route.ms, (set(),0))

        route.hello_update('b', {'c','d'}, {'e','f','a','p'}, {'a'})
        self.assertEqual(route.mpr, ({'c','b'},2))
        self.assertEqual(route.ms, ({'b'},1))

        route.hello_update('d', {'d','a'}, {'x'}, {'x'})
        self.assertEqual(route.mpr, ({'c','b','d'},3))
        self.assertEqual(route.ms, ({'b'},1))

        route.hello_update('d', {'d'}, {'a','x','g'}, {'g','a'})
        self.assertEqual(route.mpr, ({'b','d'},4))
        self.assertEqual(route.ms, ({'b','d'},2))

        route.hello_update('e', {'d','a'}, {'f'}, {'f'})
        self.assertEqual(route.mpr, ({'b','d'},4))
        self.assertEqual(route.ms, ({'b','d'},2))

        route.hello_update('d', {'d'}, {'a','x','g'}, {'g','x'})
        self.assertEqual(route.mpr, ({'b','d'},4))
        self.assertEqual(route.ms, ({'b'},3))


if __name__ == '__main__':
    unittest.main()
